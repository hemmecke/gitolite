#!/usr/bin/perl
use strict;
use warnings;

use lib $ENV{GL_LIBDIR};
use Gitolite::Rc;
use Gitolite::Common;
use Gitolite::Easy;

=for usage
Usage for this command is not that simple.  Please read the full documentation
in doc/gkm.mkd or online at http://sitaramc.github.com/gitolite/gkm.html.
=cut

usage() if @ARGV and $ARGV[0] eq '-h';

my $rb = $rc{GL_REPO_BASE};
my $ab = $rc{GL_ADMIN_BASE};
# This will be the subdirectory under "keydirs" in which the guest
# keys will be stored. To prevent denial of service, this directory
# should better start with 'zzz'.
my $guestkeys_dir = "zzzzz-guests";
my $forbidden_id_pattern = qr(^[^@]+$);
my $gkm = $rc{COMMANDS}{'gkm'};
if(ref($gkm) eq 'HASH') {
    $forbidden_id_pattern = $rc{COMMANDS}{'gkm'}{FORBIDDEN_ID_PATTERN} || '.';
    if(defined $rc{COMMANDS}{'gkm'}{GUESTS_DIRECTORY}) {
        my $gd = $rc{COMMANDS}{'gkm'}{GUESTS_DIRECTORY};
        $guestkeys_dir = $gd if ($gd =~ /[0-9A-Za-z_-]+/);
    }
}

print "[$gkm]\n";
print "[$forbidden_id_pattern]\n";
print "[$guestkeys_dir]\n";

# save arguments for later
my $operation = shift || 'list';
my $keyid     = shift || '';

# get the actual userid
my $gl_user = $ENV{GL_USER};
die "you are not in the the group \@guest-key-managers\n"
    unless in_group('guest-key-managers');

# get to the keydir
chdir("$ab/keydir");

# ----
# first collect the keys

# get the list of pubkey files
my %guestkeys = ();
my $fp;

# Note that each pubkey has a path of the following form:
# $guestkeys_dir/KEYMANAGER/KEYID.pub
# We store all keys into %guestkeys. Keys that don't live under
# $guestkeys_dir will be stored with owner set to "!NO-GUEST-KEY!".
# Yes, with the exclamation marks in order to distinguish from a
# real guest-key-manager.
for my $pubkey (`find . -type f -name "*.pub" 2>/dev/null| sort`) {
    chomp($pubkey);
    $pubkey =~ s|^\./||;
    $fp = fingerprint($pubkey);
    if ($pubkey =~ m|^$guestkeys_dir/([^/]+)/(.*)\.pub$|) {
        $guestkeys{$1}{$2} = $fp;
    } else {
        $pubkey =~ s|^.*/||;
        $pubkey =~ s|\.pub$||;
        $guestkeys{'!NO-GUEST-KEY!'}{$pubkey} = $fp;
    }
}

if ( $operation eq 'list' ) {
    print "Hello $gl_user, you manage the following guest keys:\n";
    for (keys %{$guestkeys{$gl_user}}) {
        $fp = fingerprint("$guestkeys_dir/$gl_user/$_.pub");
        print "$fp: $_\n";
    }
    print "\n\n";
    exit;
}

if($keyid eq '' or $keyid =~ /$forbidden_id_pattern/) {
       die "keyid matches forbidden pattern: '$keyid'\n";
}

if ( $operation eq 'add' ) {
    print STDERR "Please supply the new key on STDIN.\n";
    print STDERR "Try something like this:\n";
    print STDERR 'cat foo.pub | ssh git@GITOLITESERVER gkm add '."$keyid\n";
    add_guest( $gl_user, $keyid, safe_stdin() );
} elsif ( $operation eq 'del' ) {
    del_guest( $gl_user, $keyid );
}

exit;

###################################################################
# only function definitions are following
###################################################################

# make a temp clone and switch to it
our $TEMPDIR;
BEGIN { $TEMPDIR = `mktemp -d -t tmp.XXXXXXXXXX`; }
END { `/bin/rm -rf $TEMPDIR`; }

sub cd_temp_clone {
    chomp($TEMPDIR);
    hushed_git( "clone", "$rb/gitolite-admin.git", "$TEMPDIR" );
    chdir($TEMPDIR);
    my $ip = $ENV{SSH_CONNECTION};
    $ip =~ s/ .*//;
    my $email = $ENV{GL_USER};
    if (! ($email =~ m(@))) { $email .= '@' . $ip };
    # Record the keymanager in the gitolite-admin repo as author of the change.
    hushed_git( "config", "user.email", "$email" );
    hushed_git( "config", "user.name",  "'$ENV{GL_USER} from $ip'" );
}

sub fingerprint {
    my $fp = `ssh-keygen -l -f $_[0]`;
    die "does not seem to be a valid pubkey\n" unless $fp =~ /(([0-9a-f]+:)+[0-9a-f]+) /i;
    return $1;
}

sub safe_stdin {
    # read one line from STDIN
    my $data;
    my $ret = read STDIN, $data, 4096;
    # current pubkeys are approx 400 bytes so we go a little overboard
    die "could not read pubkey data" . ( defined($ret) ? "" : ": $!" ) . "\n" unless $ret;
    die "pubkey data seems to have more than one line\n" if $data =~ /\n./;
    return $data;
}

sub hushed_git {
    system("git " . join(" ", @_) . ">/dev/null 2>/dev/null");
}

sub add_guest {
    my ( $gl_user, $keyid, $keymaterial ) = @_;

    # add a new "marked for addition" key for $gl_user.
    cd_temp_clone();
    chdir("keydir");
    my $path="$guestkeys_dir/$gl_user";
    my $newpubkey="$path/$keyid.pub";
    _mkdir($path);
    _print($newpubkey, $keymaterial);
    my $fp = fingerprint($newpubkey);
    print STDERR "\nAdding $fp $keyid\n";
    # Check that there isn't a key with the same fingerprint under a
    # different keyid.
    for my $u (keys %guestkeys) {
        for my $id (keys %{$guestkeys{$u}}) {
            if (($id eq $keyid) xor ($fp eq $guestkeys{$u}{$id})) {
                print STDERR "Found  $guestkeys{$u}{$id} $id\n";
                die "Cannot add key.\n";
            }
        }
    }
    exit if (`git status -s` eq '');
    hushed_git( "add", "." ) and die "git add failed\n";
    hushed_git( "commit", "-m", "'gkm: add $gl_user/$keyid ($fp)'" ) and die "git commit failed\n";
    system("gitolite push >/dev/null 2>/dev/null") and die "git push failed\n";
}

sub del_guest {
    my ( $gl_user, $keyid ) = @_;
    my $fp = $guestkeys{$gl_user}{$keyid};
    die "key '$keyid' not found\n" unless $fp;

    cd_temp_clone();
    chdir("keydir");

    hushed_git( "rm", "$guestkeys_dir/$gl_user/$keyid.pub" ) and die "git rm failed\n";
    hushed_git( "commit", "-m", "'gkm: del $gl_user/$keyid ($fp)'" ) and die "git commit failed\n";
    system("gitolite push >/dev/null 2>/dev/null") and die "git push failed\n";
}
